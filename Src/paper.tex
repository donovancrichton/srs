\documentclass[11pt]{article}
\usepackage{epsfig}
\usepackage{cite}
\usepackage{amssymb}
\usepackage{amsmath}
\setlength\topmargin{1.5pc} \setlength\textheight{600pt}
\setlength\textwidth{32pc}

\newcommand{\dbtable}[5]{{\small\begin{tabular}[t]{#2}
      \hline
      \multicolumn{#1}{|l|}{#3} \\
      \hline \hline
      #4 \\
      \hline
      #5 \\
      \hline
\end{tabular}}}
\title{Verified Time Balancing of Security Protocols 
  \\ \large A Case Study}

\author{Student Name: Donovan Crichton\\
Student Number: u6881864}
\date{}


\begin{document}

\maketitle
  \section{A description of the ZRTP Protocol up to public key 
           exposure.}
  \subsection{The Message Preamble}
  All ZRTP Messages are prefixed by a preamble, message length
  and message type. 
  \begin{itemize}
  \item Let $pr$ represent the message preamble $0x505a$ followed
        by a 16-bit message length in 32-bit words, followed by the 
        message type 2-word block string (e.g. ``hello'').
  \end{itemize}
  \section{The Hello Messages}
  \begin{itemize}
    \item Let $v$ represent the 4-character long string containing 
          the version of the ZRTP protocol.
    \item Let $c$ represent the client identification string which
          identifies the vendor and release of the ZRTP software.
    \item Let $h3$ represent the following:
       \begin{itemize}
       \item Let $h0$ represent a 256-bit random nonce.
       \item Let $h1$ represent a hash of $h0$ with SHA-256.
       \item Let $h2$ represent a hash of $h1$ with SHA-256.
       \item Let $h3$ represent a hash of $h2$ with SHA-256.
       \end{itemize}
    \item Let $z$ represent the 96-bit long unique identifier for 
          the ZRTP endpoint. This is a random number generated at 
          installation time to act as a key when looking up 
          shared secrets in a local cache.
    \item Let $fs$ represent a 4-bit long sequence of flags. 
          The leading bit is 0, the second represents a 
          signature-capable flag, the third a MiTM flag to 
          identify that this message was sent from a PBX. The 
          fourth and final bit represents a passive flag 
          whichis only used on devices that send hello, 
          but will never send commit messages.
    \item Let $hc$ represent the number (count) of hashing 
            algorithms.
    \item Let $cc$ represent the number of cipher algorithms.
    \item Let $ac$ represent the number of auth tag types.
    \item Let $kc$ reresent the number of key agreement types.
    \item Let $sc$ represent the number of SAS types.
    \item Let $hs$ represent the ordered set of hashing algorithms.
    \item Let $cs$ represent the set of cipher algorithms.
    \item Let $as$ represent the set of SRTP auth tag types.
    \item Let $ks$ represent the set of key agreement types.
    \item Let $ss$ represents the set of short authentication 
          string types.
    %TODO: Figure out what m actually does.
    \item Let $m$ represents the machine authentication code 
          that finishes the ZRTP message.
  \end{itemize}
  \subsubsection{Alice says Hello to Bob}
   $alice_0(pr,v,c,h3,z,fs,hc,cc,ac,kc,sc,hs,cs,as,ks,ss,m)$
  \subsubsection{Bob receives Alice's Hello}
   $bob_0(pr_{a0},v_{a0},c_{a0},h3_{a0},z_{a0},fs_{a0},hc_{a0}
     ,cc_{a0},ac_{a0},kc_{a0},sc_{a0},hs_{a0},cs_{a0}
          ,as_{a0},ks_{a0},ss_{a0},m_{a0})$
  \subsubsection{Bob acknowledges Alice's hello via HelloAck}
  $bob_1(pr)$
  \subsubsection{Alice receives Bob's HelloAck}
  $alice_1(pr_{b1})$
  \subsubsection{Bob says Hello to Alice}
  $bob_2(pr,v,c,h3,z,fs,hc,cc,ac,kc,sc,hs,cs,as,ks,ss,m)$
  \subsubsection{Alice receives Bob's Hello}
   $alice_2(pr_{b2},v_{b2},c_{b2},h3_{b2},z_{b2},fs_{b2},hc_{a0}
     ,cc_{b2},ac_{b2},kc_{b2},sc_{b2},hs_{b2},cs_{b2}
          ,as_{b2},ks_{b2},ss_{b2},m_{b2})$
  \subsubsection{Alice acknowledges Bob's Hello via HelloAck}
  $alice_3(pr)$
  \subsubsection{Bob receives Alice's HelloAck}
  $bob_3(pr_{a3})$
  \subsection{The Commit Message}
  \begin{itemize}
    \item Let $ha$ represent the negotiated hash algorithm.
    \item Let $ca$ represent the negotiated cipher algorithm.
    \item Let $at$ represent the negotiated auth-tag type.
    \item Let $kt$ represent the negotiated key-agreement type.
    \item Let $st$ represent the negotiated short authentication
            string type.
    \item Let $hvi$ represent the initatiors hash value where:
      \begin{itemize}
        \item Let $svi$ represent a random number.
        \item Let $g$ represent the base.
        \item Let $p$ represent the prime modulus.
        \item $svi$, $g$, and $p$ are all functions of $kt$
              such that: 
        \item Let $pvi = mod(g^{svi},p)$.
        \item Let $||$ denote bitwise concatenation.
        \item Let $dh2i$ represent the initiators DH Part 2 Message.
        \item Let $hellor$ represent the responders Hello Message.
        \item $hvi = ha(dh2i || hellor)$
      \end{itemize}
  \end{itemize}
  \subsubsection{Bob prepares a DH Part 2 Message}
  $bob_4(pr,h1,rs1i,rs2i,asi,psi,pvi,m)$
  \subsubsection{Bob sends a Commit to Alice}
  $bob_5(pr,h2,z,ha,ca,at,kt,st,hvi,m)$
  \subsubsection{Alice receives Bob's Commit}
  $alice_4(pr_{b5},h2_{b5},z_{b5},ha_{b5},ca_{b5},at_{b5},kt_{b5}
    ,st_{b5},hvi_{b5},m_{b5})$
  \subsection{The DH Part 1 Message}
  \begin{itemize}
    \item Let $rstr$ represent a message denoting ``Responder''.
    \item Let $s1r$ represent the responders first shared secret
          if it exists, or null otherwise.
    \item Let $s2r$ represent the responders second shared secret
          if it exists, or null otherwise.
    \item Let $rs1r = m(s1r,rstr)$ represent the non-invertible 
          hash of the responders first retained shared secret.
    \item Let $rs2r = m(m2r,rstr)$ represent the non-invertible
          hash of the responders second retained shared secret.
    \item Let $auxr$ represent the responders auxiliary shared 
          secret.
    \item Let $rh3$ represent the responder H3 value.
    \item Let $asr = m(auxr,rh3)$ represent the non-invertible hash
          of the responders auxiliary shared secret.
    \item Let $pbxr$ represent the responders pbx shared secret.
    \item Let $psr = m(pbx,rstr)$ represent the non-invertible
          hash of the responders pbx shared secret.
    \item Let $pvr$ represent the responders hash value where:
      \begin{itemize}
        \item Let $svr$ represent a random number.
        \item Let $g$ represent the base.
        \item Let $p$ represent the prime modulus.
        \item $svr$, $g$, and $p$ are all functions of $kt$
              such that: 
        \item Let $pvr = mod(g^{svr},p)$.
      \end{itemize}
  \end{itemize}
  \subsubsection{Alice sends DH Part 1 to Bob}
  $alice_5=(pr,h1,rs1r,rs2r,asr,psr,pvr,m)$
  \subsubsection{Bob receives Alice's DH Part 1}
  $bob_6=(pr_{a5},h1_{a5},rs1r_{a5},rs2r_{a5},asr_{a5},psr_{a5},
           pvr_{a5},m_{a5})$
  \subsubsection{Bob checks Alice's DH Part 1 and calculates DH 
               Result}
  \begin{itemize}
    \item if $pvr_{a5} = p_{b5}$ or $pvr_{a5} = p_{b5} - 1$ then 
          terminate protocol. Otherwise continue:
    \item Let $dhr = mod(pvr_{a5}^{svi_{b5}},p)$ represent the 
          DH result.
  \end{itemize}
  \subsection{The DH Part 2 Message}
  \begin{itemize}
    \item Let $istr$ represent a message denoting ``Initiator''.
    \item Let $s1$ represent the initiators first shared secret if
          it exists or null otherwise.
    \item Let $s2$ represent the initiators second shared secret if
          it exists or null otherwise.
    \item Let $rs1i = m(s1,istr)$ represent the non-invertible hash 
          of the initiators first retained shared secret.
    \item Let $rs2i = m(s2,istr)$ represent the non-invertible hash
          of the intiators second retained shared secret.
    \item Let $auxi$ represet the auxiliary shared secret.
    \item Let $ih3$ represent the initiators H3 value.
    \item Let $asi = m(auxi,ih3)$ represent the non-invertible hash
          of the initiators auxiliary shared secret.
    \item Let $pbxi$ represent the pbx shared secret.
    \item Let $psi = m(pbx,istr)$ represent the non-invertible
          hash of the initiators pbx shared secret.
  \end{itemize}
  \subsubsection{Bob sends DH Part 2 to Alice}
  $bob_7 = bob_4$
  \subsubsection{Alice receives Bob's DH Part 2}
  $alice_6(pr_{b7},h1_{b7},rs1i_{b7},rs2i_{b7},asi_{b7},
           psi_{b7},pvi_{b7},m_{b7})$
  \subsubsection{Alice checks Bob's DH Part 2 and calculates DH 
               Result}
  \begin{itemize}
    \item if $pvi_{b7} = p_{a5}$ or $pvr_{b7} = p_{a5} - 1$ then 
          terminate protocol. Otherwise continue:
    \item if $hash(bob_7 || alice_0) \neq hvi_b5$ then terminate 
          protocol. Otherwise continue:
    \item Let $dhr = mod(pvr_{b7}^{svi_{a5}},p)$ represent the 
          DH result.
  \end{itemize}
  \section{A Simplification of ZRTP}
  \subsection{Negotiated Protocols}
  To simplify the formal verification of timing observability, 
  this simplified protocol will forgo the agreement process between
  the parties and all parties will assume the following:
  \begin{itemize}
    \item Let $ha$ represent the agreed-upon hash algorithm 
          SHA-256.
    \item Let $ca$ represent the agreed-upon cipher algorithm 
          AES-1.
    \item Let $at$ represent the agreed-upon auth tag type
          HS32 - based on HMAC-SHA1 in RFC 3711.
    \item Let $kt$ represent the agreed-upon key agreement
          type DH2k, p=2048 Bit Prime as per RFC 3526.
    \item Let $st$ represent the agreed-upon short authentication
          string type B32
  \end{itemize}
  \subsubsection{The Hello and HelloAck Messages}
  If this protocol assumes pre-agreement on protocol parameters
  by Alice and Bob, and assumes that both Alice and Bob pre-compute
  $h0$, $h1$, $h2$, and $h3$ then the ``Hello'' messages and the 
  corresponding ``HelloAck'' messages can be considered to have
  a constant time, and thus possibly be ommited for the purpose of
  verifying timing observability.
\end{document}
