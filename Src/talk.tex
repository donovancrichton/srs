\documentclass{beamer}
\usepackage[utf8]{inputenc}

\usepackage{minted}
\usepackage{pgf}
\usepackage{tikz}
\usepackage{upquote}
\usepackage{hyperref}
\usepackage{graphicx}
\usetikzlibrary{arrows,automata,positioning}

\setbeamertemplate{footline}[frame number]
\setbeamertemplate{navigation symbols}{}

\title{Verified Time Balancing of Security Protocols}
\author{Donovan Crichton}
\date{January 2019}

\begin{document}
 
\frame{\titlepage}

\begin{frame}[fragile]
  \frametitle{Motivation}
  \begin{itemize}
    \item ASD manually verifies vendor code with containing cryptographic
            processes.
    \item Formal Methods: A mathematically based approach to the
            specification and verification of software.
    \item Can we reduce some of the resources ASD spends on 
            manual verification by replacing with automatic verification?
    \item A case study.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Formally Verifying a Time Balanced Security Protocol}
  \begin{itemize}
    \item Attackers can gain information from message timing.
    \item Can we model this invariant? Naively all operations have the
            same running time.
    \item Can we ensure that assumptions on this model hold for the
            implementation?
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The ZRTP Protocol}
  \begin{itemize}
    \item Initially started with ZRTP.
    \item ZRTP is complex and makes many decisions.
    \item Simplified version that contains just enough detail to 
            allow us to attempt to prove some interesting things!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Simplified Protocol}
    \begin{itemize}
      \item Commit messages contain hashes of 256 bit random nonce.
      \item Diffie-Hellman key exchange contains modulo arithmetic.
      \item How can we formally guarantee the timing of operations?
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Approach}
  \begin{itemize}
    \item We can use the notion of propositions as types.
    \item Dependently typed functional programming languages
            also act as theorem provers for a higher-order
                  constructive logic.
    \item We can model this protocol in such a language, Idris.
    \item We can express proofs about properties of the protocol.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Quick Background 1 - Currying}
  All functions treated as taking a single argument. \\ \\
  $f : \mathbb{N} \rightarrow \mathbb{N} \rightarrow \mathbb{N}$ \\
  $f = + $ \\ \\
  Applying an argument to a multi argument function returns the 
  rest of the function! \\ \\
  $f(2) : \mathbb{N} \rightarrow \mathbb{N}$ \\
  $f(2) = 2 + $ \\ \\
  Finally all arguments are applied. \\ \\
  $f(2, 3) : \mathbb{N}$ \\
  $f(2, 3) = 2 + 3 = 5 $
\end{frame}

\begin{frame}[fragile]
  \frametitle{Quick Background 2 - Propositions as Types}
     \begin{table}[h!]
    \begin{tabular}{c|c|c|c}
    \textbf{Logic Term} & \textbf{Logic Symbol} & \textbf{Idris Symbol}
      & \textbf{Idris Type} \\
    \hline
      Implication & p $\Rightarrow$ q & p \mintinline{haskell}{->} q
      & Arrow \\
      Conjunction & p $\land$ q & \mintinline{haskell}{(p, q)} 
      & Pair (Product) \\
      Disjunction & p $\lor$ q & \mintinline{haskell}{Either p q}
      & Enum (Sum)\\
      Negation & $\lnot$ p & \mintinline{haskell}{p -> Void} &
      Void Type \\
      IFF/Eq & p $\equiv$ q, p $\iff$ q & \mintinline{haskell}{(p -> q, q -> p)} 
      & Pair Arrows \\
      Universal & $\forall$ x. P x & 
      \mintinline{haskell}{p -> Type} & $\Pi$ Type \\
      Existential & $\exists$ x. P x 
      & \mintinline{haskell}{(x ** P x)} & $\Sigma$ Type \\
      \hline
       & & \mintinline{haskell}{p = q} & Type Equality
    \end{tabular}
  \end{table}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Quick Background 3 - Idris Syntax and Functions as Types}
  Building a vector type in Idris: 
  \begin{minted}{haskell}
    data Vec : Nat -> Type -> Type where
      Nil  : Vec 0 a
      (::) : (x : a) -> Vec n a -> Vec (n + 1) a
  \end{minted}
  We can parameterise types over values to capture invariants in the model.
  \begin{minted}{haskell}
    append : Vec n a -> Vec m a -> Vec (n + m) a
    append Nil ys = ys
    append (x :: xs) ys = x :: append xs ys 
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Capturing time invariants in a small DSL}
  %insert picture for prg here!
\end{frame}

\end{document}
